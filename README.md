
## Описание

Данный проект реализует кастомный пул потоков для высоконагруженных серверных приложений на Java. В отличие от стандартного `ThreadPoolExecutor`, пул поддерживает:
- несколько очередей задач (по числу потоков),
- балансировку задач по принципу Round Robin,
- параметр minSpareThreads (минимальное число резервных потоков),
- детальное логирование всех ключевых событий,
- настраиваемые политики отказа,
- гибкую настройку параметров пула.

Проект состоит из следующих файлов:
- **CustomExecutor.java** — интерфейс управления пулом;
- **CustomThreadPool.java** — реализация пула потоков;
- **CustomRejectionPolicy.java** — обработчик отказа;
- **Main.java** — демонстрационная программа.

---

## Как это работает

- **corePoolSize** — минимальное количество потоков (и очередей), которые всегда активны.
- **maxPoolSize** — максимальное количество потоков, которые могут быть созданы при высокой нагрузке.
- **keepAliveTime** — время простоя, после которого избыточные потоки завершаются.
- **queueSize** — максимальное количество задач в каждой очереди.
- **minSpareThreads** — минимальное число свободных (резервных) потоков, которые пул поддерживает даже при низкой нагрузке.

Задачи распределяются по очередям по принципу Round Robin: каждая новая задача попадает в следующую очередь по кругу, что обеспечивает равномерную загрузку потоков.

Если все очереди заполнены и пул достиг максимального размера, задача отклоняется с помощью кастомной политики отказа, которая логирует событие и выбрасывает исключение.

---

---

## Анализ производительности

**Сравнение с ThreadPoolExecutor и промышленными аналогами (Tomcat, Jetty):**
- CustomThreadPool показывает схожую пропускную способность и задержки при равных параметрах.
- Благодаря minSpareThreads и динамическому масштабированию пул быстрее реагирует на всплески нагрузки, не создавая лишних потоков при низкой активности.
- Round Robin балансировка предотвращает "запирание" задач в одной очереди, что может встречаться в стандартных пулах без балансировки.
- В промышленных серверах (Tomcat, Jetty) также реализованы параметры minSpareThreads, maxThreads, keepAliveTime, что подтверждает актуальность выбранной архитектуры.

**Вывод:**  
CustomThreadPool не уступает стандартным решениям по производительности, а по гибкости и прозрачности управления потоками и отказами превосходит их в ряде сценариев.

---

## Рекомендации по настройке

- **corePoolSize**: равен числу ядер CPU для вычислительных задач, для I/O-bound задач — в 2–4 раза больше.
- **maxPoolSize**: обычно 2–4 × corePoolSize, чтобы избежать избыточного потребления ресурсов.
- **queueSize**: подбирается экспериментально, для серверных приложений — 100–1000.
- **keepAliveTime**: 30–60 секунд для сценариев с переменной нагрузкой.
- **minSpareThreads**: 1–2 для быстрого реагирования на всплески, для высоконагруженных систем — 5–10% от corePoolSize.

---

## Принцип работы балансировки

- Для каждой задачи выбирается очередь по циклическому принципу (Round Robin).
- Каждая очередь закреплена за своим worker-потоком.
- Если очередь переполнена, а потоков меньше maxPoolSize — создается новый поток и очередь.
- Если все потоки заняты и очереди заполнены — задача отклоняется через политику отказа.

**Преимущества:**
- Равномерное распределение нагрузки между потоками.
- Исключается ситуация, когда одна очередь перегружена, а другие простаивают.
- Система масштабируется динамически и поддерживает minSpareThreads даже при низкой нагрузке.

---

## Логирование

Пул логирует все ключевые события:
- создание и завершение потоков,
- поступление задач в очередь,
- выполнение задач,
- idle timeout (завершение потока по простою),
- отказ в обработке задачи.

Это упрощает отладку и мониторинг работы пула.

---

## Демонстрационная программа

В `Main.java` показаны:
- запуск пула с выбранными параметрами,
- отправка задач и их выполнение,
- обработка перегрузки,
- корректное завершение работы пула.

---

## Заключение

CustomThreadPool:
- обеспечивает производительность на уровне стандартных решений,
- гибко настраивается под любые сценарии,
- реализует прозрачное логирование и отказоустойчивость,
- легко расширяется и интегрируется в серверные приложения.

---



